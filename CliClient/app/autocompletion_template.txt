export IFS=$'\n'

_|__APPNAME__|_completion() {

	# COMP_WORDS contains each word in the current command, the last one
	# being the one that needs to be completed. Convert this array
	# to an "escaped" line which can be passed to the joplin CLI
	# which will provide the possible autocompletion words.

	ESCAPED_LINE=""
	for WORD in "${COMP_WORDS[@]}"
	do
		if [[ -n $ESCAPED_LINE ]]; then
			ESCAPED_LINE="$ESCAPED_LINE|__SEP__|"
		fi
		WORD="${WORD/\"/|__QUOTE__|}"
		WORD="${WORD/\\(/|__OPEN_RB__|}"
		WORD="${WORD/\\)/|__CLOSE_RB__|}"
		WORD="${WORD/\\ /|__SPACE__|}"
		ESCAPED_LINE="$ESCAPED_LINE$WORD"
	done

	# Call joplin with the --autocompletion flag to retrieve the autocompletion
	# candidates (each on its own line), and put these into COMREPLY.

	# echo "joplindev --autocompletion --ac-current "$COMP_CWORD" --ac-line "$ESCAPED_LINE"" > ~/test.txt

	COMPREPLY=()
	while read -r line; do
		COMPREPLY+=("$line")
	done <<< "$(|__APPNAME__| --autocompletion --ac-current "$COMP_CWORD" --ac-line "$ESCAPED_LINE")"

	# If there's only one element and it's empty, make COMREPLY
	# completely empty so that default completion takes over
	# (i.e. regular file completion)
	# https://stackoverflow.com/a/19062943/561309

	if [[ -z ${COMPREPLY[0]} ]]; then
		COMPREPLY=()
	fi
}

complete -o default -F _|__APPNAME__|_completion |__APPNAME__|
complete -o default -F _|__APPNAME__|_completion |__APPALIAS__|